inner_join(tracks_and_artist, artists_info)
tracks_and_genres <- inner_join(tracks_and_artist, artists_info)  %>% unnest(genres)
artists_info
artists_info %>% unnest(genres)
last_error()
artists_info %>% unnest(genres)
save(artists_info, file ="artists_info.RData")
for (i in 2:floor(nrow(tracks_and_artist)/50)) {
aux <- get_artists(tracks_and_artist[(i-1)*50:(i-1)*50+50,] %>% pull(artist.id) %>% unique()) %>% as_tibble()
artists_info <- bind_rows(artists_info,aux)
}
#DATA GATHERING
#example from my own most listened tracks
source('01_setup.R')
library('spotifyr')
Sys.setenv(SPOTIFY_CLIENT_ID = '44855249207d40619183b073132a6407')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '2296850888224ff0bb4e35ad23962578')
access_token <- get_spotify_access_token()
#autorizar a coger datos de usuario
aut <- get_spotify_authorization_code()
#selecting my own playlists
plists <- get_my_playlists()
plists <- rbind(plists,get_my_playlists(offset = 19))
#get each playlist's tracks
first <- get_playlist_audio_features(playlist_uris = plists$id[1])
tracks <- tibble(select(first,c(1,6:17,28)))
#I skip playlists taht cant be collected (fusion playlists and daily mics most likely)
for (i in c(3:7,9,10,13:29)) {
aux <- get_playlist_audio_features(playlist_uris = plists$id[i])
aux <- select(aux,c(1,6:17,28))
tracks <- add_row(tracks,aux)
}
tracks <- tracks[,c(1,13,2:12,14)]
glimpse(tracks)
#get genre
tracks_and_artist <- tracks %>%
select(track.id, track.artists) %>%
unnest(track.artists) %>%
select(track.id, id) %>%
rename(artist.id = id)
#get_artists limit is 50
artists_info <- get_artists(tracks_and_artist[1:50,] %>% pull(artist.id) %>% unique()) %>% as_tibble()
for (i in 2:floor(nrow(tracks_and_artist)/50)) {
aux <- get_artists(tracks_and_artist[(i-1)*50:(i-1)*50+50,] %>% pull(artist.id) %>% unique()) %>% as_tibble()
artists_info <- bind_rows(artists_info,aux)
}
save(artists_info, file ="artists_info.RData")
glimpse(artists_info)
artists_info <- artists_info %>% select(genres, id) %>%  rename(artist.id = id)
artists_info %>% unnest(genres)
glimpse(artists_info)
tracks_and_genres <- inner_join(tracks_and_artist, artists_info)  %>% drop_na() %>% unnest(genres)
tracks_and_genres %>% group_by(genres) %>% count() %>% arrange(desc(n))
tracks_and_genres %>% mutate(value = TRUE) %>% pivot_wider(names_from = genres, values_from = value, values_fill = FALSE)
#tengo en tracks_and_genres los tracks con su genero asociado, mientras que en tracks tengo los tracks con sus ids
tracks_genre_features <- left_join(tracks_and_genres,tracks,)
tracks_genre_features <- select(tracks_genre_features,c(1:15))
save(tracks_genre_features, file = "tracks_genres_features.RData")
#Data preparation and classification
#Loading and setting the data obtained in Data_collection
load("tracks_genres_features.RData")
save(tracks_genre_features, file = "tracks_genre_features.RData")
#Data preparation and classification
#Loading and setting the data obtained in Data_collection
load("tracks_genre_features.RData")
#get rid of unnecessary variables (artist.id...)
track_features <- select(tracks_genre_features,c(1,3,5:15))
#standarize all varaibles
t_max <- max(track_features$tempo)
t_min <- min(track_features$tempo)
var(track_features$tempo)
var(c(1 1 1 1))
var(c(1 1 1 1))
var(c(1,1,1,1))
var(c(1,1,1,2))
#standarize all varaibles
track_features %>% mutate(,tempo = (tempo - mean(tempo))/sd(tempo))
#standarize all varaibles
track_features %>% mutate(,tempo = (tempo - mean(tempo))/sd(tempo)) %>% select(,"tempo")
#standarize all varaibles
track_features %>% mutate(, tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)))
#standarize all varaibles
track_features %>% mutate(, tempo = (tempo-min(tempo))/(max(tempo)-min(tempo))) %>% select(,tempo)
#standarize all varaibles
track_features <- track_features %>% mutate(, tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)))
track_features %>% mutate(, loudness = (loudness-min(loudness))/(max(loudness)-min(loudness))) %>% select(loudness)
track_features <- track_features %>% mutate(, loudness = (loudness-min(loudness))/(max(loudness)-min(loudness))) %>% select(loudness)
#get rid of unnecessary variables (artist.id...)
track_features <- select(tracks_genre_features,c(1,3,5:15))
#standarize all varaibles
track_features <- track_features %>% mutate(, tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)))
track_features <- track_features %>% mutate(, loudness = (loudness-min(loudness))/(max(loudness)-min(loudness)))
#Intento de primer proyecto con spoti
#La idea es tomar una gran cantidad de datos, con genero de cancion, playlist o usuario del que toma el track
#y crear samples de esa poblacion para comparar la efectividad de los algoritmos de clustering en ejemplos reales
#NOTA: abajo del todo hay una prueba con mis playlist
source('01_setup.R')
#paquete para la api de spoti
library('spotifyr')
#de momento me quedo sin mode y key
features <- track_features %>% select(-c("key","mode"))
pca_f <- features %>% select(-c("track.id","genres")) %>% prcomp()
summary(pca_aux)
summary(pca_f)
#DATA GATHERING
#example from my own most listened tracks
source('01_setup.R')
library('spotifyr')
Sys.setenv(SPOTIFY_CLIENT_ID = '44855249207d40619183b073132a6407')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '2296850888224ff0bb4e35ad23962578')
access_token <- get_spotify_access_token()
#autorizar a coger datos de usuario
aut <- get_spotify_authorization_code()
#selecting my own playlists
plists <- get_my_playlists()
plists <- rbind(plists,get_my_playlists(offset = 19))
#get each playlist's tracks
first <- get_playlist_audio_features(playlist_uris = plists$id[1])
tracks <- tibble(select(first,c(1,6:17,28)))
#I skip playlists taht cant be collected (fusion playlists and daily mics most likely)
for (i in c(3:7,9,10,13:29)) {
aux <- get_playlist_audio_features(playlist_uris = plists$id[i])
aux <- select(aux,c(1,6:17,28))
tracks <- add_row(tracks,aux)
}
tracks <- tracks[,c(1,13,2:12,14)]
glimpse(tracks)
#get genre
tracks_and_artist <- tracks %>%
select(track.id, track.artists) %>%
unnest(track.artists) %>%
select(track.id, id) %>%
rename(artist.id = id)
#get_artists limit is 50
artists_info <- get_artists(tracks_and_artist[1:50,] %>% pull(artist.id) %>% unique()) %>% as_tibble()
for (i in 2:floor(nrow(tracks_and_artist)/50)) {
aux <- get_artists(tracks_and_artist[(i-1)*50:(i-1)*50+50,] %>% pull(artist.id) %>% unique()) %>% as_tibble()
artists_info <- bind_rows(artists_info,aux)
}
save(artists_info, file ="artists_info.RData")
glimpse(artists_info)
artists_info <- artists_info %>% select(genres, id) %>%  rename(artist.id = id)
artists_info %>% drop_na() %>% unnest(genres)
glimpse(artists_info)
tracks_and_genres <- inner_join(tracks_and_artist, artists_info)  %>% drop_na() %>% unnest(genres)
tracks_and_genres %>% group_by(genres) %>% count() %>% arrange(desc(n))
# para filtrar algunos generos
tracks_and_genres %>% filter(genres %in% c("rock", "alternative rock"))
# para hacer que cada genero sea una columna
tracks_and_genres %>% select(-artist.id) %>% distinct() %>% mutate(value = TRUE) %>% pivot_wider(names_from = genres, values_from = value, values_fill = FALSE)
#tengo en tracks_and_genres los tracks con su genero asociado, mientras que en tracks tengo los tracks con sus ids
tracks_genre_features <- left_join(tracks_and_genres,tracks,)
tracks_genre_features <- select(tracks_genre_features,c(1:15))
save(tracks_genre_features, file = "tracks_genre_features.RData")
tracks_genre_features$track.id
#filter genres
track_features$genres %>% count()
#filter genres
track_features %>% group_by(genres) %>% count()
#filter genres
track_features %>% group_by(genres) %>% count() %>% desc()
#filter genres
track_features %>% group_by(genres) %>% count() %>% desc(n)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))[,]
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genre != c("trap latino", "trap triste", "trap argentino"))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genre !c("trap latino", "trap triste", "trap argentino"))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genre!c("trap latino", "trap triste", "trap argentino"))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genre!c("trap latino"))
?grepl
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(grepl(c("trap latino", "trap triste", "trap argentino"),genre))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(grepl(c("trap latino", "trap triste", "trap argentino"),genres))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genres!c("trap latino", "trap triste", "trap argentino"))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(genres!=c("trap latino", "trap triste", "trap argentino"))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(grepl("trap latino | trap triste | trap argentino"),genres)
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(grepl("trap latino | trap triste | trap argentino",genres))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features %>% filter(!grepl("trap latino | trap triste | trap argentino",genres))
#filter genres
d %>% group_by(genres) %>% count() %>% arrange(desc(n))
#trap latino, trap triste, trap argentino are repeated, so we remove them
d <- track_features %>% filter(!grepl("trap latino | trap triste | trap argentino",genres))
#filter genres
d %>% group_by(genres) %>% count() %>% arrange(desc(n))
#trap latino, trap triste, trap argentino are repeated, so we remove them
d <- track_features %>% filter(!grepl("trap latino | trap triste | trap argentino",genres))
#filter genres
d %>% group_by(genres) %>% count() %>% arrange(desc(n))
#trap latino, trap triste, trap argentino are repeated, so we remove them
d <- track_features %>% filter(!grepl("trap latino|trap triste|trap argentino",genres))
#filter genres
d %>% group_by(genres) %>% count() %>% arrange(desc(n))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#trap latino, trap triste, trap argentino are repeated, so we remove them
track_features <- track_features %>% filter(!grepl("trap latino|trap triste|trap argentino",genres))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
?arrange
?desc
#filter genres
track_features %>% group_by(genres) %>% count() %>% order()
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange()
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<20)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<10)
#filter genres
d <- track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<10)
d[,1]
c(d[,1])
#remove all varibles with less than 15 elements
low_n <- track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
track_features <- track_features %>% filter(!grepl(i,genres))
for (i in c(d[,1])) {
track_features <- track_features %>% filter(!grepl(i,genres))
}
for (i in c(low_n[,1])) {
track_features <- track_features %>% filter(!grepl(i,genres))
}
#remove all varibles with less than 15 elements
low_n <- track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
low_n <- c(low_n[,1])
#remove all varibles with less than 15 elements
low_n <- track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
for (i in low_n[,1]) {
track_features <- track_features %>% filter(!grepl(i,genres))
}
low_n[[,1]]
low_n[[,1]
low_n[[,1]]
as.vector(low_n[,1])
[[as.vector(low_n[,1])]]
as.vector(low_n[,1])
low <- as.vector(low_n[,1])
for (i in low) {
track_features <- track_features %>% filter(!grepl(i,genres))
}
for (i in 1:length(low)) {
track_features <- track_features %>% filter(!grepl(low[i],genres))
}
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<10)
for (i in 1:length(low)) {
track_features <- track_features %>% filter(!grepl(low[i],genres))
}
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<10)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<10)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<6)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<4)
#remove all varibles with less than 15 elements
low <- c("trance mexicano|west austrian hop hop|electro|latin|latin hip hop|reggaeton|deep groove house|brazilian edm|brostep|complextro|mexican edm|pop rap|rawstyle|canadian metal|pop|rap rock|frenchcore|hardstyle|filter house|full on|post-teen pop|trance|alt z|alternative r&b|candy pop|dark pop|electropop|metropopolis|spanish indie pop|swedish electropop|swedish synthpop|viral pop|australian dance|melbourne bounce|melbourne bounce international")
track_features %>% filter(!grepl(low,genres))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<4)
l <- track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
d <- track_features %>% filter(!grepl(low,genres))
d %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
#remove all varibles with less than 15 elements
low <- c("trance mexicano|west australian hop hop|electro|latin|latin hip hop|reggaeton|deep groove house|brazilian edm|brostep|complextro|mexican edm|pop rap|rawstyle|canadian metal|industrial metal|pop|rap rock|frenchcore|hardstyle|filter house|full on|post-teen pop|trance|alt z|alternative r&b|candy pop|dark pop|electropop|metropopolis|spanish indie pop|swedish electropop|swedish synthpop|viral pop|australian dance|melbourne bounce|melbourne bounce international")
track_features <- track_features %>% filter(!grepl(low,genres))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
#remove all varibles with less than 15 elements
low <- c("trance mexicano|west australian hip hop|electro|latin|latin hip hop|reggaeton|deep groove house|brazilian edm|brostep|complextro|mexican edm|pop rap|rawstyle|canadian metal|industrial metal|pop|rap rock|frenchcore|hardstyle|filter house|full on|post-teen pop|trance|alt z|alternative r&b|candy pop|dark pop|electropop|metropopolis|spanish indie pop|swedish electropop|swedish synthpop|viral pop|australian dance|melbourne bounce|melbourne bounce international")
track_features <- track_features %>% filter(!grepl(low,genres))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<15)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n)) %>% filter(n<20)
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#Data preparation and classification
#Loading and setting the data obtained in Data_collection
source("01_setup.R")
#filter genres
track_features %>% group_by(genres) %>% count() %>% arrange(desc(n))
#standarize all varaibles
track_features <- track_features %>% mutate(, tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)))
track_features <- track_features %>% mutate(, loudness = (loudness-min(loudness))/(max(loudness)-min(loudness)))
features <- track_features %>% select(-c("key","mode"))
#funciones para hacer el clutering por densidad
#primero el dbscan
dbs <- function(X,epsilon,MinPts){
C_d <- X %>% select(c(1,2)) %>% dbscan(epsilon,MinPts)
X <- mutate(X, dbs = factor(C_dbs$cluster))
return(X)
}
#Voy a definir una función que haga kmeans y kmeans++
#X un data frame con variables a estudiar en las dos primeras columnas y k numero de clusters
km_clustering <- function(X,k,num_km){
C_km<- X %>% select(c(1,2)) %>% kmeans(k,nstart = num_km)
#lo mismo pero con kmeans++
C_kpp<- X %>% select(c(1,2)) %>% kmeanspp(k)
#Voy a pintar el clustering que me da el algoritmo
#primero creo una variable que asigne la clase de cada cluster en X
X <- mutate(X, km = factor(C_km$cluster), kpp = factor(C_kpp$cluster))
return(X)
}
km_clustering_custom <- function(X,c){
C_km<- X %>% select(c(1,2)) %>% kmeans(c)
#primero creo una variable que asigne la clase de cada cluster en X
X <- mutate(X, km = factor(C_km$cluster))
return(X)
}
#jerarquico
h_clustering <- function(X,method,k){
C_h <- X %>% select(c(1:2)) %>% dist() %>% hclust(method)
#dendrograma
dendrogram <- plot(C_h)
#conseguir una particion concreta
partition_h<-cutree(C_h,k)
X <- mutate(X, hc = factor(partition_h))
return(X)
}
#classification
#first test
track_features %>% select(-c("track.id","genres"))
?NbClust
#classification
#first test
track_features %>% select(-c("track.id","genres")) %>% NbClust()
#classification
#first test
track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans" index= "shiouette")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans" index= "silhouette")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans" index= "sihlouette")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans", index= "sihlouette")
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans", index= "silhouette")
clust1$Best.nc
#classification
#first test
clust1 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "kmeans")
clust2 <- track_features %>% select(-c("track.id","genres")) %>% NbClust(method = "complete")
#Data preparation and classification
#Loading and setting the data obtained in Data_collection
source("01_setup.R")
#for dbscan epsilon and minpts have to be determined
# rule of thumb: MinPts = 2*dimension of data. This data has a lot of duplicates so we will do 3*dim
MinPts <- 3*ncol(track_features %>% select.list(-c("track.id","genres")))
?ncol
ncol(track_features)
track_features %>% select(-c("track.id","genres"))
track_features
#for dbscan epsilon and minpts have to be determined
# rule of thumb: MinPts = 2*dimension of data. This data has a lot of duplicates so we will do 3*dim
MinPts <- track_features %>% select.list(-c("track.id","genres")) %>% 3*ncol()
#for dbscan epsilon and minpts have to be determined
# rule of thumb: MinPts = 2*dimension of data. This data has a lot of duplicates so we will do 3*dim
MinPts <- 3*ncol(track_features %>% select(-c("track.id","genres")))
#for dbscan epsilon and minpts have to be determined
# rule of thumb: MinPts = 2*dimension of data. This data has a lot of duplicates so we will do 3*dim
MinPts <- 3*ncol(track_features %>% select(-c("track.id","genres")))
?knn
track_features %>% select(-c("track.id","genres")) %>% kNN(1)
neigh <- track_features %>% select(-c("track.id","genres")) %>% kNN(1)
neigh$sort
neigh$dist
neigh$dist[,10:20]
neigh$dist[10:20,]
neigh$dist[10:50,]
neigh$dist[45:50,]
count(neigh$dist == 0)
count(filter(neigh$dist == 0)
length(filter(neigh$dist == 0)
length(filter(neigh,neigh$dist == 0)
nrow(filter(neigh,neigh$dist == 0)
nrow(filter(neigh,neigh$dist == 0))
nrow(filter(neigh,neigh$dist == 0))
neigh$dist==0
nrow(filter(neigh$dist,neigh$dist == 0))
?count
count(neigh$dist==0)
count(as.logical(neigh$dist==0)
neigh <- track_features %>% select(-c("track.id","genres")) %>% kNN(2)
neigh <- track_features %>% select(-c("track.id","genres")) %>% kNN(2)
neigh$dist
neigh$dist[100]
neigh$dist[150]
neigh$id
neigh$k
neigh$dist
d <- neigh$dist
d <- neigh$dist[,2]
d <- d>0
d <- neigh$dist[,2]
d <- d[!0]
d <- d[which(!0)]
d <- neigh$dist[,2]
d <- apply(d,function(x){x[!=0]})
d <- apply(d,function(x){x[which(!=0)]})
d <- apply(d,function(x){x[which(!0)]})
d <- apply(d,function(x){x[!0]})
d <- lapply(d,function(x){x[!0]})
d <- lapply(d,function(x){x[!0]})
d <- as.list(neigh$dist[,2])
d <- list(neigh$dist[,2])
d <- lapply(d,function(x){x[!0]})
d <- neigh$dist[,2]
d <- neigh$dist[,2]
d[!=0]
d[!0]
d[!0]
mean(d)
plot(d)
d[>0.001]
d[d>0.001]
d <- d[d>0.00001]
min(d)
mean(d)
ep <- mean(d)
track_features %>% select(-c("track.id","genres")) %>% dbs(,ep,MinPts)
track_features %>% select(-c("track.id","genres")) %>% dbs(,ep,MinPts)
#funciones para hacer el clutering por densidad
#primero el dbscan
dbs <- function(X,epsilon,MinPts){
C_d <- X %>% select(c(1,2)) %>% dbscan(epsilon,MinPts)
X <- mutate(X, dbs = factor(C_dbs$cluster))
return(X)
}
#for dbscan epsilon and minpts have to be determined
# rule of thumb: MinPts = 2*dimension of data. This data has a lot of duplicates so we will do 3*dim
MinP <- 3*ncol(track_features %>% select(-c("track.id","genres")))
track_features %>% select(-c("track.id","genres")) %>% dbs(,ep,MinP)
track_features %>% select(-c("track.id","genres")) %>% dbs(,ep,MinPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbs(,ep)
track_features %>% select(-c("track.id","genres")) %>% dbs(,epsilon = ep, MinPts = MinP)
#funciones para hacer el clutering por densidad
#primero el dbscan
dbs <- function(X,epsilon,MinPts){
C_d <- X %>% dbscan(epsilon,MinPts)
X <- mutate(X, dbs = factor(C_dbs$cluster))
return(X)
}
track_features %>% select(-c("track.id","genres")) %>% dbs(,epsilon = ep, MinPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbscan(,epsilon = ep, MinPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbscan(,eps = ep, minPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbscan(,eps = min(d), minPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbscan(,eps = min(d)/2, minPts = MinP)
track_features %>% select(-c("track.id","genres")) %>% dbscan(,eps = min(d), minPts = MinP)
clust3 <- track_features %>% select(-c("track.id","genres")) %>% dbscan(,eps = min(d), minPts = MinP)
track_features %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition))
#add the clustering results to the main data
analysis <- track_features %>% select(c("track.id","genre"))
#add the clustering results to the main data
analysis <- track_features %>% select(c("track.id","genres"))
analysis <- analysis %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition))
analysis
#do a kmeans after filtering noise points
aux <- track_features %>% select(-c("track.id","genres")) %>% mutate(dbs=factor(clust3$cluster)) %>% filter(dbs != 0)
clust4 <- aux %>% selec(-c("dbs")) %>% dbscan(ep,MinP)
clust4 <- aux %>% select(-c("dbs")) %>% dbscan(ep,MinP)
clust4 <- aux %>% select(-c("dbs")) %>% NbClust(method = "kmeans")
#add the clustering results to the main data
analysis <- track_features %>% select(c("track.id","genres"))
analysis <- analysis %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition), km_filter = factor(clust4$Best.partition))
analysis <- analysis %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition))
analysis <- analysis %>% mutate(km_filter = factor((clust4$Best.Partition)*(clust3$cluster!=0)+(clust3$cluster)*(clust3$cluster==0))
analysis
(clust4$Best.Partition)*(clust3$cluster!=0)+(clust3$cluster)*(clust3$cluster==0)
(clust4$Best.Partition)*(clust3$cluster!=0)+(clust3$cluster)*(clust3$cluster==0))
analysis <- analysis %>% mutate(km_filter = factor((clust4$Best.Partition)*(clust3$cluster!=0)+(clust3$cluster)*(clust3$cluster==0)))
analysis <- analysis %>% mutate(km_filter = factor((clust4$Best.Partition)*(clust3$cluster!=0)))
clust3$cluster!=0
as.numeric(clust3$cluster!=0)
analysis <- analysis %>% mutate(km_filter = factor((clust4$Best.Partition)*as.numeric(clust3$cluster!=0)))
clust4$Best.Partition
clust4$Best.partition
analysis <- analysis %>% mutate(km_filter = factor((clust4$Best.partition)*as.numeric(clust3$cluster!=0)))
analysis <- analysis %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition))
analysis
#add the clustering results to the main data
analysis <- track_features %>% select(c("track.id","genres"))
analysis <- analysis %>% mutate(dbs = factor(clust3$cluster),km = factor(clust1$Best.partition), hc = factor(clust2$Best.partition))
analysis
